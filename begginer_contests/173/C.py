H, W, K = map(int, input().split())

#Ci,jを表す配列を作成する
c = []
for i in range(H):
    c.append(input())

ans = 0

# 各行のYes or Noに関して列のYes or Noの全通りを試す
# bit演算を行うことで全通りを簡単に試すことができる
for h in range((1 << H)):
    for w in range((1 << W)):
        black = 0
        # 各行の各列
        for i in range(H):
            for j in range(W):
                # 対象の行と列が消されていなければ、#があるかを確認し黒の個数を1足してやる
                # h >> i　-> hのiビット右シフト
                # hは二進数で赤で塗りつぶすパターンを表す。iは行番号で、
                # 右に対象行bit分だけずらすと現在見ている行が0か1のどちらかが求まる
                #
                # イメージ
                #   0 1 2 3 4
                # 0 . # . . .
                # 1 # # # . .
                # 2 . # . . .
                # 3 . # # . .
                # 4 . . # . .
                # 
                # この時に、行の0〜4の2がiの時にc[i][j]を調べる場合、マスキングされていたら#をカウントできない
                # その場合Hは0101(0行めと2行目をマスク)のようにマスキングする行を1、そうでない行を0と表すので、
                # Hを対象行bit分ずらしてやると、現在調べようとしているi行めの0 or 1のフラグが一番右になるので、
                # そのフラグが1ならば、1 & 1 -> trueとなり 1 == 0 になりblackが加算されない
                # 逆に0 & 1 -> false -> 0 == 0 -> true の時はblackを加算してやる
                if ((h >> i) & 1) == 0 and ((w >> j) & 1) == 0 and c[i][j] == '#':
                    black += 1
        if black == K:
            ans += 1

print(ans)


        




    